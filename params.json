{"name":"Storage-wars","tagline":"Experiment med IndexedDB","body":"# IndexedDB och Application Cache \r\n## Experiment och anteckningar\r\n\r\n***\r\n\r\n## IndexedDB\r\n\r\nEn databas som sitter på klientsidan i webbläsaren. Den gör offline läge möjligt och kan även användas för att göra online applikationer mycket snabbare. Den är i NoSQL stil, där man lagrar objekt istället för records eller rader. Den är transaktionsbaserad.\r\n\r\n### Vad finns det för problem med IndexedDB?\r\n\r\nAPI-en är inte samma på varje webbläsaren, och inte hellre samma på varje version av en webbläsare. Så det är svårt att använda IndexedDB för en cross-browser app och appen kan sluta fungera om användaren uppdaterar sin webbläsare. I skrivande stund funkar den inte på Safari, Opera, iOS, Opera Mobile eller Android Browser.\r\n\r\n### Hur söker man i databasen?\r\n\r\nIndexedDB kan själv inte sökas med den slags queries man använder i SQL, till exempel \"Hitta alla objekt som matchar en visst set\" eller \"Hitta alla objekt som innehåller 'Sodra'\" eller logiska OR eller AND.\r\n\r\nHär är alla sökmetoder:\r\n\r\n* `IDBKeyRange.only()` - Sök exakt nyckel\r\n* `IDBKeyRange.bound()` - Sök nyckel inom ett intervall\r\n* `IDBKeyRange.upperBound()` - Sök allt som är lägre än en viss nyckel\r\n* `IDBKeyRange.lowerBound()` - Sök allt högre än en viss nyckel\r\n\r\n### Vad händer om en databas request (read eller write) misslyckas?\r\n\r\n`window.indexedDB.onerror()` event triggers. Databasen rullas tillbaka och din Javascript kan hantera felet med en callback funktion till `onerror()` event. Du kan också avbryta en request (om det tar för lång tid till exempel) med en `transaction.abort()` metod, och den ska rullas tillbaka.\r\n\r\n### Hur bra är IndexedDB med att hantera stora mängder data?\r\n\r\nDet kan gå långsamt och eftersom Javascript är så klart single-threaded, hela appen kan hänga sig. Man kan förmodligen fixa concurrency med en Web Worker, men jag har inte testat just det ännu. Annars får man fixa en overlay med \"Vi jobbar på saken\" meddelande medan den jobbar med databasen. Med `transaction.abort()` metod kan vi ge användaren en knapp för att avbryta och rullar tillbaka.\r\n\r\n### Hur mycket data kan man lagra i IndexedDB?\r\n\r\nMan börjar med 10MB. Om det blir större ska webbläsaren fråga användaren för tillstånd att använda mer. Oavsett tillstånd kan det aldrig vara mer än 250MB. OBS! Ingen error kommer ifall man överstiger 250MB.\r\n\r\n### Hur smidigt är felhanteringen?\r\n\r\nGanska smidigt. Fel bubblar upp, så man slipper hantera fel för varje request objekt, utan att man kan fixa fel till själva transaction eller databas objekt.\r\n\r\n## Application Cache\r\n\r\nMed App Cache kan alla filer i en app (HTML-filer, CSS-filer, JS-filer och bilderna) lagras på användarens hård disk för att använda i offline läge eller för att göra online appar snabbare. Det fixar man genom att lista alla filer i en manifest fil.\r\n\r\n### Hur mycket kan man cacha?\r\n\r\nMan har 8MB för att börja med. Om man överstiger det ska IE11 frågar användaren för tillstånd att använda mer. Den maximala varierar mellan webbläsare. Chromes maximal är inte per domän utan att det finns en maximal för samtliga domäner (så din app kan nå maximalen på grund av att en Chrome användare var på en annan sida som cachade mycket).\r\n\r\n### Kan appen kolla cache status?\r\n\r\nJapp. Javascript kan kolla cache status med `window.applicationCache`. På så sätt kan din Javascript kolla om sidan har uppdaterats och byta ut den gamla cachen för den nya.\r\n\r\n### Vad finns det för problem med App Cache?\r\n\r\n* När klienten laddar ner alla filer som ska cachas måste nerladdning av varje fil lyckas eller hela processen avslutas. Om en fil t ex returnerar 404 får klienten ingen cache av någon fil alls. Dessutom finns det väldigt vag felhantering där man får bara \"Error\" utan någon felkod att förklara vad gick fel. \r\n\r\n* Cachen uppdateras bara när manifest filen uppdateras. Om man uppdatera t ex index.html, användarna (både online och offline) ska se den gamla tills manifest filen ändras. Detta gör det viktigt att manifest filen själv inte cachas. Klienten kan kolla om manifest filen har ändrats efter sidan har redan laddats med `window.applicationCache.updateReady()`   metoden.\r\n\r\n* Om manifest filen ändras i mitten av att klienten laddar ner innehåll, ska nerladdning misslyckas. Men manifest filen måste ändras för att uppdatera cachen! Det betyder att App Cache är bara en bra lösning för appar som ändras sällan.\r\n\r\n* Man kan inte uppdatera en del av cachen. Om cachen ska uppdateras måste klienten laddar ner varje fil från början. Man uppdaterar cachen för alla filer eller inga filer.\r\n\r\n* Varje fil som en sida använder måste cachas. T ex om index.html har bil.jpg som inte är i manifest filen, bil.jpg ska inte visas - inte även i online läge.\r\n\r\n### Finns det ett alternativ till App Cache?\r\n\r\nEn stökig lösning är att använda IndexedDB för att lagra allting (html filerna, CSS-filerna, bilderna, mm). Förmodligen inte en fungerande lösning men jag bara slänger ut idén.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}